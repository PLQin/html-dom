(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{wGLp:function(n,e,t){"use strict";t.r(e);var o=t("q1tI"),c=t.n(o),d=t("Ov9x"),i=t("2G++");e.default=function(){return c.a.createElement(c.a.Fragment,null,c.a.createElement(d.a,{content:"\n## 1. 使用 `offsetWidth` 减去 `clientWidth`\n\n`clientWidth` 属性表示没有滚动条的宽度。另一方面，`offsetWidth` 属性包含滚动条(如果有)。\n\n这是获得滚动条最简单的方式: \n\n~~~ javascript\nconst scrollbarWidth = document.body.offsetWidth - document.body.clientWidth;\n~~~\n\n## 2. 使用虚拟元素\n\n我们创建两个虚拟 `div` 元素，其中一个是另一个的子元素。然后计算他们的宽度差。\n\n~~~ javascript\nconst calculateScrollbarWidth = function() {\n    // 创建父元素\n    const outer = document.createElement('div');\n    outer.style.visibility = 'hidden';\n    outer.style.overflow = 'scroll';\n    \n    // 添加到 `body` 元素中\n    document.body.appendChild(outer);\n\n    // 创建子元素\n    const inner = document.createElement('div');\n    outer.appendChild(inner);\n\n    // 计算他们的宽度差\n    const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;\n\n    // 删除父元素\n    document.body.removeChild(outer);\n\n    return scrollbarWidth;\n};\n~~~\n\n如果将\"显示滚动条\"选项设置为\"基于鼠标或触控板自动\"或\"滚动时\"，这个方法在 macOS 上不起作用。\n\n![在 macOS上 显示滚动条选项](/assets/scroll-macos.png)\n"}),c.a.createElement(i.a,{slugs:["append-to-an-element","create-an-element","determine-the-height-and-width-of-an-element","remove-an-element"]}))}}}]);
//# sourceMappingURL=posts-calculate-the-size-of-scrollbar.bff6d42bcbb4b706671a.js.map