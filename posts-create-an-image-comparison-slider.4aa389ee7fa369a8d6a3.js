(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{owAV:function(n,e,t){"use strict";t.r(e);var i=t("q1tI"),s=t.n(i),a=t("TJpk"),o=t("mcK/"),d=t("Ov9x"),l=t("2G++");e.default=function(){return s.a.createElement(s.a.Fragment,null,s.a.createElement(a.Helmet,null,s.a.createElement("meta",{name:"keywords",content:"\n            addEventListener, getBoundingClientRect, image comparison slider, mousedown event, mousemove event,\n            mouseup event, previous sibling, previousElementSibling, next sibling, nextElementSibling,\n            set css style, set element width\n        "})),s.a.createElement(d.a,{content:'\n在这篇文章中，我们将创建一个滑块来比较两个 imges。滑块有三个元素组织如下:\n\n~~~ html\n<div class="container">\n    \x3c!-- 显示修改后的图像 --\x3e\n    <div class="modified-image"></div>\n\n    \x3c!-- 调整 --\x3e\n    <div class="resizer" id="dragMe"></div>\n\n    \x3c!-- 原始图像 --\x3e\n    <img src="/path/to/original/image.png" />\n</div>\n~~~\n\n## The markup\n\n最初，修改后的图像将占据容器的一半宽度。它绝对位于容器上：\n\n~~~ css\n.container {\n    position: relative;\n}\n.modified-image {\n    /* 绝对定位 */\n    left: 0;\n    position: absolute;\n    top: 0;\n\n    /* 取容器的全高和半宽 */\n    height: 100%;\n    width: 50%;\n}\n~~~\n\n我们不使用 `img` 标签在此处显示修改后的图像，因为图像可以缩放。相反，我们将修改后的图像用作修改后的元素的背景：\n\n~~~ html\n<div\n    class="modified-image"\n    style="background-image: url(\'/path/to/modified/image.png\')"\n>\n</div>\n~~~\n\n修改后的元素使用更多样式在所需位置显示背景图像：\n\n~~~ css\n.modified-image {\n    background-position: top;\n    background-repeat: no-repeat;\n    background-size: auto 100%;\n    ...\n}\n~~~\n\n设置大小调整器的位置要容易得多。它显示在容器的中央：\n\n~~~ css\n.resizer {\n    /* 绝对定位 */\n    left: 50%;\n    position: absolute;\n    top: 0;\n\n    /* 大小 */\n    height: 100%;\n    width: 2px;\n\n    /* 背景 */\n    background-color: #cbd5e0;\n\n    /* 表示它可以调整大小 */\n    cursor: ew-resize;\n}\n~~~\n\n## 事件处理\n\n当用户移动大小调整器时，我们计算鼠标已移动了多远。然后根据当前鼠标位置设置修改元素和调整大小元素的位置。\n\n关于这个想法的更多信息，你可以查看[创建可调整大小的拆分视图](/create-resizable-split-views)文章。这是一段代码:\n\n~~~ javascript\n// 查询元素\nconst resizer = document.getElementById(\'dragMe\');\nconst leftSide = resizer.previousElementSibling;\n\n// 鼠标当前位置\nlet x = 0;\nlet y = 0;\n\n// 修改元素宽度\nlet leftWidth = 0;\n\n// 绑定 mousedown 事件\n// 当用户拖动调整大小时触发\nconst mouseDownHandler = function(e) {\n    // 获取当前鼠标位置\n    x = e.clientX;\n    y = e.clientY;\n    leftWidth = leftSide.getBoundingClientRect().width;\n\n    // 将侦听器绑定到 `document` 上\n    document.addEventListener(\'mousemove\', mouseMoveHandler);\n    document.addEventListener(\'mouseup\', mouseUpHandler);\n};\n\nconst mouseMoveHandler = function(e) {\n    // 鼠标移动了多远\n    const dx = e.clientX - x;\n    const dy = e.clientY - y;\n\n    let newLeftWidth = (leftWidth + dx) * 100 / resizer.parentNode.getBoundingClientRect().width;\n    newLeftWidth = Math.max(newLeftWidth, 0);\n    newLeftWidth = Math.min(newLeftWidth, 100);\n\n    // 设置修改和调整大小元素的宽度\n    leftSide.style.width = `${newLeftWidth}%`;\n    resizer.style.left = `${newLeftWidth}%`;\n};\n\n// 将事件处理\nresizer.addEventListener(\'mousedown\', mouseDownHandler);\n~~~\n\n当用户移动鼠标时，我们必须确保鼠标没有移动到容器外。这就是为什么我们必须将newLeftWidth与0和100个百分比进行比较:\n\n~~~ javascript\nconst mouseMoveHandler = function(e) {\n    ...\n\n    newLeftWidth = Math.max(newLeftWidth, 0);\n    newLeftWidth = Math.min(newLeftWidth, 100);\n};\n~~~\n\n下面是你可以使用的演示。\n\n_Photo by [frank mckenna](https://unsplash.com/@frankiefoto) on [Unsplash](https://unsplash.com/photos/OD9EOzfSOh0)_\n'}),s.a.createElement(o.a,{src:"/demo/create-an-image-comparison-slider/index.html"}),s.a.createElement(l.a,{slugs:["attach-or-detach-an-event-handler","create-a-range-slider","create-resizable-split-views","get-siblings-of-an-element","make-a-draggable-element","set-css-style-for-an-element"]}))}}}]);
//# sourceMappingURL=posts-create-an-image-comparison-slider.4aa389ee7fa369a8d6a3.js.map